# RiX Language AST Reference

This document provides a comprehensive reference for all token types generated by the tokenizer and AST node types created by the parser.

## Section 1: Token Types

### Number
**Purpose:** Represents all mathematical number formats supported by RiX  
**Syntax:** 
- Integers: `42`, `-17`
- Decimals: `3.14`, `-.5`, `2.`
- Rationals: `3/4`, `-5/8`
- Mixed numbers: `1..3/4`, `-2..1/3`
- Intervals: `2:5`, `1.5:3.7`, `-2:0`
- Repeating decimals: `0.12#34`, `1.#3`
- Scientific notation: `1.23E-4`, `5E6`
- Decimal intervals: `1.23[56:67]`

### Identifier
**Purpose:** Represents variable names, function names, and system identifiers  
**Syntax:** 
- User identifiers (lowercase first): `x`, `myVar`, `Î±`
- System identifiers (uppercase first): `SIN`, `PI`, `Matrix`

### Symbol
**Purpose:** Represents operators, punctuation, and delimiters  
**Syntax:** All mathematical and functional operators including:
- Arithmetic: `+`, `-`, `*`, `/`, `^`, `**`
- Assignment: `:=`, `:=:`, `:<:`, `:>:`
- Comparison: `=`, `?=`, `<`, `>`, `<=`, `>=`
- Pipe operations: `|>`, `|>>`, `|>?`, `|>:`
- Array generators: `|+`, `|*`, `|:`, `|^`
- Brackets: `(`, `)`, `[`, `]`, `{`, `}`
- Punctuation: `,`, `;`, `.`, `_`
- Unit operators: `~[`, `~{`
- Postfix operators: `@`, `?` (when followed by parentheses), `~[`, `~{`

### String
**Purpose:** Represents quoted literals, backticks, and comments  
**Syntax:**
- Double quotes: `"hello"`, `""complex""`, `"""multiline"""`
- Backticks: `` `code` ``, ``` ``nested`` ```
- Comments: `# line comment`, `/* block */`, `/** doc **/`

### Postfix Operators
**Purpose:** Represents postfix operations for precision, queries, and function calls
**Syntax:**
- AT operator: `expr@(arg)` - precision/metadata access
- ASK operator: `expr?(arg)` - membership/query testing  
- Enhanced CALL: `expr(args)` - universal function call on any expression
- Operator functions: `+(a,b,c)`, `*(x,y)` - operators as variadic functions
- Scientific units: `expr~[unit]` - attach scientific units to expressions
- Mathematical units: `expr~{unit}` - attach mathematical units to expressions

### PlaceHolder
**Purpose:** Represents numbered placeholders for parameter positioning  
**Syntax:** `_1`, `_2`, `__3`, `___42`

### SemicolonSequence  
**Purpose:** Represents multiple consecutive semicolons for matrix/tensor separators  
**Syntax:** `;;`, `;;;`, `;;;;`

### End
**Purpose:** Marks the end of input stream  
**Syntax:** Automatically generated at end of input

## Section 2: AST Node Shapes

### Number
```javascript
{
  value: string,      // Raw number value as string
  original: string    // Original text from source
}
```

### String
```javascript
{
  value: string,      // Content between delimiters
  kind: string,       // 'quote' | 'backtick' | 'comment' | 'unit change'
  original: string    // Original text including delimiters
}
```

### UserIdentifier
```javascript
{
  name: string,       // Normalized identifier name
  original: string    // Original text from source
}
```

### SystemIdentifier
```javascript
{
  name: string,       // Normalized system identifier name
  systemInfo: object, // Result from system lookup function
  original: string    // Original text from source
}
```

### PlaceHolder
```javascript
{
  place: number,      // Placeholder number (1, 2, 3, etc.)
  original: string    // Original text from source
}
```

### NULL
```javascript
{
  original: string    // Original underscore text
}
```

### BinaryOperation
```javascript
{
  operator: string,   // Operator symbol
  left: ASTNode,      // Left operand
  right: ASTNode,     // Right operand
  original: string    // Combined original text
}
```

### UnaryOperation
```javascript
{
  operator: string,   // Operator symbol ('+', '-', etc.)
  operand: ASTNode,   // Operand expression
  original: string    // Original text
}
```

### Assignment
```javascript
{
  operator: string,   // Assignment operator (':=', ':=:', etc.)
  left: ASTNode,      // Left-hand side (variable/function)
  right: ASTNode,     // Right-hand side (value/expression)
  original: string    // Combined original text
}
```

### FunctionCall
```javascript
{
  function: ASTNode,  // Function identifier
  arguments: {
    positional: [ASTNode],        // Positional arguments
    keyword: {string: ASTNode}    // Named arguments
  },
  original: string    // Combined original text
}
```

### PropertyAccess
```javascript
{
  object: ASTNode,    // Object being accessed
  property: ASTNode,  // Property name or expression
  original: string    // Combined original text
}
```

### FunctionDefinition
```javascript
{
  name: ASTNode,      // Function name identifier
  parameters: {
    positional: [{name: string, defaultValue: ASTNode}],
    keyword: [{name: string, defaultValue: ASTNode}],
    conditionals: [ASTNode],
    metadata: object
  },
  body: ASTNode,      // Function body expression
  definitionType: string, // 'standard' | 'pattern'
  original: string    // Combined original text
}
```

### PatternMatchingFunction
```javascript
{
  name: ASTNode,      // Function name identifier
  parameters: object, // Same structure as FunctionDefinition
  patterns: [ASTNode], // Array of pattern expressions
  metadata: object,   // Global function metadata
  original: string    // Combined original text
}
```

### FunctionLambda
```javascript
{
  parameters: object, // Same structure as FunctionDefinition
  body: ASTNode,      // Lambda body expression
  original: string    // Combined original text
}
```

### ParameterList
```javascript
{
  parameters: object, // Parameter structure
  original: string    // Original text
}
```

### Pipe
```javascript
{
  left: ASTNode,      // Input expression
  right: ASTNode,     // Target function/expression
  original: string    // Combined original text
}
```

### ExplicitPipe
```javascript
{
  left: ASTNode,      // Input expression
  right: ASTNode,     // Target with placeholders
  original: string    // Combined original text
}
```

### Map
```javascript
{
  left: ASTNode,      // Collection to map over
  right: ASTNode,     // Mapping function
  original: string    // Combined original text
}
```

### Filter
```javascript
{
  left: ASTNode,      // Collection to filter
  right: ASTNode,     // Filter predicate
  original: string    // Combined original text
}
```

### Reduce
```javascript
{
  left: ASTNode,      // Collection to reduce
  right: ASTNode,     // Reduction function
  original: string    // Combined original text
}
```

### IntervalStepping
```javascript
{
  interval: ASTNode,  // Base interval
  step: ASTNode,      // Step size
  original: string    // Combined original text
}
```

### IntervalDivision
```javascript
{
  interval: ASTNode,  // Interval to divide
  count: ASTNode,     // Number of divisions
  type: string,       // 'equally_spaced'
  original: string    // Combined original text
}
```

### IntervalPartition
```javascript
{
  interval: ASTNode,  // Interval to partition
  count: ASTNode,     // Number of partitions
  original: string    // Combined original text
}
```

### IntervalMediants
```javascript
{
  interval: ASTNode,  // Base interval
  levels: ASTNode,    // Number of mediant levels
  original: string    // Combined original text
}
```

### IntervalMediantPartition
```javascript
{
  interval: ASTNode,  // Interval for mediant partition
  levels: ASTNode,    // Partition levels
  original: string    // Combined original text
}
```

### IntervalRandom
```javascript
{
  interval: ASTNode,  // Source interval
  parameters: ASTNode, // Random selection parameters
  original: string    // Combined original text
}
```

### IntervalRandomPartition
```javascript
{
  interval: ASTNode,  // Interval to partition randomly
  count: ASTNode,     // Number of random partitions
  original: string    // Combined original text
}
```

### InfiniteSequence
```javascript
{
  start: ASTNode,     // Starting value
  step: ASTNode,      // Step increment
  original: string    // Combined original text
}
```

### Tuple
```javascript
{
  elements: [ASTNode], // Tuple elements
  original: string    // Combined original text
}
```

### Grouping
```javascript
{
  expression: ASTNode, // Grouped expression
  original: string    // Combined original text
}
```

### GeneratorChain
```javascript
{
  start: ASTNode,     // Starting value (may be null)
  operators: [{
    type: string,     // Generator operation type
    operator: string, // Operator symbol
    operand: ASTNode  // Operation parameter
  }],
  original: string    // Combined original text
}
```

### GeneratorAdd
```javascript
{
  operator: string,   // '|+'
  operand: ASTNode,   // Addition value
  original: string    // Combined original text
}
```

### GeneratorMultiply
```javascript
{
  operator: string,   // '|*'
  operand: ASTNode,   // Multiplication factor
  original: string    // Combined original text
}
```

### GeneratorFunction
```javascript
{
  operator: string,   // '|:'
  operand: ASTNode,   // Generator function
  original: string    // Combined original text
}
```

### GeneratorFilter
```javascript
{
  operator: string,   // '|?'
  operand: ASTNode,   // Filter predicate
  original: string    // Combined original text
}
```

### GeneratorLimit
```javascript
{
  operator: string,   // '|^'
  operand: ASTNode,   // Limit condition/count
  original: string    // Combined original text
}
```

### GeneratorLazyLimit
```javascript
{
  operator: string,   // '|^:'
  operand: ASTNode,   // Lazy limit condition/count
  original: string    // Combined original text
}
```

### WithMetadata
```javascript
{
  primary: ASTNode,   // Primary element
  metadata: object,   // Metadata key-value pairs
  original: string    // Combined original text
}
```

### Array
```javascript
{
  elements: [ASTNode], // Array elements
  original: string    // Combined original text
}
```

### Matrix
```javascript
{
  rows: [[ASTNode]],  // Matrix rows (2D array)
  original: string    // Combined original text
}
```

### Tensor
```javascript
{
  structure: [object], // Multi-dimensional structure
  maxDimension: number, // Highest dimension level
  original: string    // Combined original text
}
```

### Set
```javascript
{
  elements: [ASTNode], // Set elements
  original: string    // Combined original text
}
```

### Map
```javascript
{
  elements: [ASTNode], // Map key-value pairs
  original: string    // Combined original text
}
```

### System
```javascript
{
  elements: [ASTNode], // System equations/constraints
  original: string    // Combined original text
}
```

### BlockContainer
```javascript
{
  statements: [ASTNode], // Block statements
  original: string    // Combined original text
}
```

### Derivative
```javascript
{
  function: ASTNode,  // Function to differentiate
  order: number,      // Derivative order (number of quotes)
  variable: ASTNode,  // Variable to differentiate with respect to
  evaluation: ASTNode, // Evaluation point (if specified)
  original: string    // Combined original text
}
```

### Integral
```javascript
{
  function: ASTNode,  // Function to integrate
  order: number,      // Integration order (number of quotes)
  variable: ASTNode,  // Variable to integrate with respect to
  evaluation: ASTNode, // Evaluation bounds (if specified)
  original: string    // Combined original text
}
```

### At
```javascript
{
  target: ASTNode,    // Expression being queried for precision/metadata
  arg: ASTNode,       // Precision/metadata parameter
  original: string    // Combined original text
}
```

### Ask
```javascript
{
  target: ASTNode,    // Expression being queried for membership/properties
  arg: ASTNode,       // Query parameter (range, condition, etc.)
  original: string    // Combined original text
}
```

### ScientificUnit
```javascript
{
  target: ASTNode,    // Expression being annotated with units
  unit: string,       // Scientific unit content (e.g., "m", "kg/s^2")
  original: string    // Combined original text
}
```

### MathematicalUnit
```javascript
{
  target: ASTNode,    // Expression being annotated with units
  unit: string,       // Mathematical unit content (e.g., "i", "sqrt2", "pi")
  original: string    // Combined original text
}
```

### TernaryOperation
```javascript
{
  condition: ASTNode,     // Boolean condition expression
  trueExpression: ASTNode, // Expression evaluated if condition is true
  falseExpression: ASTNode, // Expression evaluated if condition is false
  original: string        // Combined original text
}
```

### EmbeddedLanguage
```javascript
{
  language: string,   // Language identifier or 'RiX-String'
  context: object,    // Context parameters
  body: string,       // Embedded code content
  original: string    // Original backtick literal
}
```

## Section 3: Common Token Properties

All tokens include these base properties:

### Token Base Properties
```javascript
{
  type: string,       // Token type identifier
  original: string,   // Original text from source (including whitespace)
  pos: [number, number, number] // [start, valueStart, end] positions
}
```

### AST Node Base Properties
All AST nodes include these base properties:

```javascript
{
  type: string,       // Node type identifier
  pos?: [number, number], // Optional source position [start, end]
  original?: string   // Optional original source text
}
```

**Position Information:**
- `pos[0]`: Character index where token/node starts (including leading whitespace)
- `pos[1]`: Character index where token value starts (excluding delimiters for strings)
- `pos[2]`: Character index where token/node ends
- Positions are 0-based and suitable for JavaScript string slicing

**Original Text:**
- For tokens: includes any leading whitespace consumed during tokenization
- For AST nodes: contains the combined original text of all constituent tokens
- Preserves exact source representation for error reporting and code transformation

## Section 4: Postfix Operators

### AT Operator (@)
**Purpose:** Access precision, tolerance, or metadata properties of mathematical objects
**Syntax:** `expression@(parameter)`
**Precedence:** 120 (POSTFIX - highest precedence)
**Examples:**
- `PI@(1e-10)` - Get PI with precision 1e-10
- `result@(tolerance)` - Apply tolerance to result
- `(1/3)@(epsilon)` - Get rational with specified precision

### ASK Operator (?)
**Purpose:** Query membership, bounds, or boolean properties of mathematical objects
**Syntax:** `expression?(parameter)`
**Precedence:** 120 (POSTFIX - highest precedence)
**Note:** Must be followed by parentheses to distinguish from infix `?` operator
**Examples:**
- `PI?(3.14:3.15)` - Check if PI is in interval [3.14, 3.15]
- `result?(bounds)` - Test if result satisfies bounds
- `interval?(x)` - Query if x is in interval

### Enhanced CALL Operator (())
**Purpose:** Universal function call that works on any expression, not just identifiers
**Syntax:** `expression(arguments)`
**Precedence:** 120 (POSTFIX - highest precedence)
**Examples:**
- `3(4)` - Equivalent to `3 * 4` (scalar multiplication)
- `(2,3)(4,5)` - Tuple/vector operations
- `matrix(vector)` - Matrix-vector multiplication
- `f(x)(y)` - Chained function calls

### Operators as Functions
**Purpose:** Mathematical operators can be used as function identifiers
**Syntax:** `operator(arg1, arg2, ...)`
**Examples:**
- `+(2, 3, 5)` - Addition as variadic function: 2 + 3 + 5
- `*(a, b, c)` - Multiplication as function: a * b * c
- `<(x, y)` - Comparison as function: x < y
- `=(a, b)` - Equality as function: a = b

### Scientific Unit Operator (~[)
**Purpose:** Attach scientific units to mathematical expressions
**Syntax:** `expression~[unit]`
**Precedence:** 120 (POSTFIX - highest precedence)
**Examples:**
- `3~[m]` - 3 meters
- `9.8~[m/s^2]` - Acceleration in meters per second squared
- `(F/m)~[kg]` - Force per unit mass with kilogram units

### Mathematical Unit Operator (~{)
**Purpose:** Attach mathematical units or algebraic extensions to expressions
**Syntax:** `expression~{unit}`
**Precedence:** 120 (POSTFIX - highest precedence)
**Examples:**
- `2~{i}` - 2 times the imaginary unit
- `1~{sqrt2}` - 1 times square root of 2
- `(a+b)~{pi}` - Expression times pi

### Chaining Postfix Operators
**Purpose:** Multiple postfix operators can be chained for complex operations
**Precedence:** All postfix operators have same precedence and are left-associative
**Examples:**
- `PI@(1e-6)?(3.14:3.15)` - Get precise PI then check range
- `f(x)@(eps)?(bounds)` - Call function, apply precision, check bounds
- `result?(test)@(meta)` - Query result then access metadata
- `3~{i}~[V]` - Complex number with voltage units
- `expr~[m/s]@(tolerance)` - Expression with units and precision